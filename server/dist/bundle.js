/*! For license information please see bundle.js.LICENSE.txt */
(()=>{var t={198:(t,e,s)=>{const{Room:r}=s(301),a=s(740),n=s(985),i=s(139);t.exports=class extends r{onCreate(t){console.log("Game room created:",t),this.setupListeners()}async onJoin(t,e){if(n.areMaxPlayers)t.send("announcement",{message:"Room is full"});else try{const s=t.sessionId;console.log(`User with session ID ${s} has joined the game.`);const{authToken:r}=e,o=i.decode(r),l=await a.findPlayer({passwordHash:o}).select("-_id -passwordHash -__v").lean();n.addPlayerToGame(s,l);const c=n.getPlayerFromGame(s),u=n.getPlayersFromGame;t.send("getPlayers",u),this.broadcast("playerJoined",c,{except:s}),n.areMaxPlayers&&setTimeout((()=>{this.startGame()}),1e3)}catch(t){console.error("An error occurred while processing the client join request:",t)}}startGame(){const{playersGamePositions:t,playersBets:e,playersMoney:s,drawCardsForPlayers:r,playerIdGameTurn:a,serverTime:i,turnRespondTime:o}=n.startGame();for(const n in r){const l=r[n],c={};c[n]={},c[n]=l.cards;const u={players:{playersGamePositions:t,playersBets:e,playersMoney:s,drawCards:c},game:{playerTurnData:{playerIdGameTurn:a,serverTime:i,turnRespondTime:o}}};this.sendMessageToClientID(n,"initPreflopRound",u)}this.startGameTurnTimer()}updateGameRound(){if(n.isPreflopRoundFinish)this.initFlopRound();else if(n.isFlopRoundFinish)this.initTurnRound();else if(n.isTurnRoundFinish)this.initRiverRound();else if(n.isRiverRoundFinish)return void this.initGameResult();this.updatePlayerTurn()}initFlopRound(){console.log("init game flop");const{newCardsOnTable:t,betsInPool:e,playerIdGameTurn:s,serverTime:r,turnRespondTime:a}=n.initNextRound(3),i={game:{tableBets:e,tableCards:t,playerTurnData:{playerIdGameTurn:s,serverTime:r,turnRespondTime:a}}};this.broadcast("initNextRound",i)}initTurnRound(){console.log("init game turn");const{newCardsOnTable:t,betsInPool:e,playerIdGameTurn:s,serverTime:r,turnRespondTime:a}=n.initNextRound(1),i={game:{tableBets:e,tableCards:t,playerTurnData:{playerIdGameTurn:s,serverTime:r,turnRespondTime:a}}};this.broadcast("initNextRound",i)}initRiverRound(){console.log("init game river");const{newCardsOnTable:t,betsInPool:e,playerIdGameTurn:s,serverTime:r,turnRespondTime:a}=n.initNextRound(1),i={game:{tableBets:e,tableCards:t,playerTurnData:{playerIdGameTurn:s,serverTime:r,turnRespondTime:a}}};this.broadcast("initNextRound",i)}initGameResult(){console.log("init game result");const{winnerPlayerId:t,playersCards:e,betsInPool:s,winnerPlayerMoney:r}=n.getGameResult(),a={players:{playersCards:e},game:{winnerPlayerId:t,winnerPlayerMoney:r,tableBets:s}};this.broadcast("gameResult",a)}sendMessageToClientID(t,e,s){const r=this.clients.find((e=>e.sessionId===t));r&&r.send(e,s)}setupListeners(){this.onMessage("playerTurnAction",((t,e)=>{const s=t.sessionId;if(!n.isCurrentPlayerTurn(s))return;const r=n.playerTurnAction(s,e);this.startGameTurnTimer(),this.updateGameRound(),this.broadcast("updatePlayerTurnAction",r)}))}startGameTurnTimer(){n.startGameTurnTimer((()=>{this.updateGameRound()}))}updatePlayerTurn(){const t=n.changePlayerTurn();this.broadcast("updateGameTurn",t)}onLeave(t,e){console.log(`${t.id} left the game.`),n.deletePlayerFromGame(t.sessionId),this.broadcast("playerLeaveGame",t.id)}onDispose(){console.log("Game room disposed.")}}},139:(t,e,s)=>{const r=s(829),{SECRET_KEY:a}=s(697);t.exports=class{static secretKey=a;static generateToken(t){return r.sign(t,this.secretKey)}static decode(t){try{return r.verify(t,this.secretKey)}catch(t){return null}}}},697:t=>{const e=process.env.JWT_SECRET_KEY;t.exports={SECRET_KEY:e}},740:(t,e,s)=>{const r=s(37),{DB_URL:a}=s(610);r.set("strictQuery",!0);const n=s(194);r.connection.on("connected",(function(){console.log("Connected to mongo")})),r.connection.on("error",(t=>{console.log("Mongo connection ERROR",t)}));const i=new class{constructor(){}async connectDatabase(){await r.connect(a,{useNewUrlParser:!0,useUnifiedTopology:!0}).then((async()=>{console.log("DB init")}))}async createUser(t){const{nick:e,money:s,passwordHash:r}=t,a=new n({nick:e,money:s,passwordHash:r});return await a.save().then((t=>{console.log("Player saved in database")})).catch((t=>{console.log(t+" Player NOT saved in database")})),!0}updatePlayer(t){return n.updateOne({id:t.id},{$set:{score:t.score}})}findPlayer(t){return n.findOne(t)}downloadPlayer(t){return this.findPlayer(t).then((t=>t||"Player does not exist"))}downloadPlayers(){return n.find({})}};t.exports=i},610:(t,e,s)=>{s(818).config();const r=process.env.USERNAME,a=process.env.PASSWORD,n=process.env.HOST,i=process.env.DB_URL;t.exports={DB_URL:i,USERNAME:r,PASSWORD:a,HOST:n}},194:(t,e,s)=>{const r=s(37),a=new r.Schema({nick:String,money:Number,passwordHash:String});t.exports=r.model("Players",a)},239:t=>{t.exports={SERVER_PORT:3111,SOCKET_PORT:3112}},992:(t,e,s)=>{const r=s(740),a=s(935),n=s(139);t.exports=async function(t,e){const{username:s,password:i}=t.body,o=String(s),l=String(i);try{const t=o+l,s=await a.hashPassword(t);if(!await r.findPlayer({passwordHash:s}))return console.log("User does not exist in database"),e.status(404).json({success:!1,token:null});console.log("User exists in database");const i=n.generateToken(s);return e.json({success:!0,jwt:i})}catch(t){return console.error("An error occurred during registration",t),e.status(500).json({success:!1,error:"Internal server error"})}}},203:(t,e,s)=>{const r=s(992),a=s(402);t.exports={registration:a,authentication:r}},402:(t,e,s)=>{const r=s(740),a=s(935);function n(t){return!("number"==typeof t&&!isNaN(t)||"string"==typeof t&&""!==t.trim())}t.exports=async function(t,e){const{username:s,password:i,nick:o}=t.body;try{const t=s+i;if(function(t,e,s){const r=n(t),a=n(e),i=n(s);return r&&a&&i}(s,i,o))return console.log("one of the login characters is empty"),e.status(404).json({success:!1,token:null});const l=await a.hashPassword(t);if(await r.findPlayer({passwordHash:l}))return console.log("User password hash exists in database"),e.status(404).json({success:!1});console.log("User password hash  does not exist in database");const c={nick:o,money:0,passwordHash:l};return r.createUser(c),e.json({success:!0})}catch(t){return console.error("An error occurred during registration",t),e.status(500).json({success:!1,error:"Internal server error"})}}},935:(t,e,s)=>{const r=s(982),{SPECIAL_SIGN:a}=s(103),n=new class{constructor(){this.specialSign=a}hashPassword(t){return r.createHash("sha256").update(t+this.specialSign).digest("hex")}};t.exports=n},103:t=>{const e=process.env.PASSWORD_HASHER_SPECIAL_SIGN;t.exports={SPECIAL_SIGN:e}},856:t=>{t.exports={CARD_VALUE:["2","3","4","5","6","7","8","9","10","11","12","13","14"],CARD_NUMBER:["2","3","4","5","6","7","8","9","10","J","Q","K","A"],CARD_COLOR:["d","c","h","s"]}},719:t=>{t.exports={MAX_PLAYERS:5,SIT_POSITIONS:[1,2,3,4,5],GAME_POSITIONS:["dealer","smallBlind","bigBlind","player"],SMALL_BLIND_BET:1e3,BIG_BLIND_BET:2e3,MAX_PLAYER_CARDS:2,DEFAULT_PLAYER_GAME_POSITION:"player",DEFAULT_PLAYER_BET_COUNT:0,PLAYER_TURN_DURATION:15,GAME_ROUND_NAMES:["Lobby","Preflop","Flop","Turn","River"],BUTTON_TYPES:["fold","check","call","raise","bet"]}},521:(t,e,s)=>{const{CARD_VALUE:r,CARD_NUMBER:a,CARD_COLOR:n}=s(856),i=s(741);t.exports=class{static initCards(){this.createCroupierCards(),this.shuffleCroupierCards()}static createCroupierCards(){for(let t=0;t<n.length;t++){const e=n[t];for(let t=0;t<a.length;t++){const s={name:e+a[t],suit:e,value:r[t]};i.addCard(s)}}}static shuffleCroupierCards(){i.shuffleCards()}static get getCards(){return i.getCards}static removeFirstCardFromDeck(){return i.subtractFirstCard}static getCardsFromDeck(t){const e=[];for(let s=0;s<t;s++){const t=this.removeFirstCardFromDeck();e.push(t)}return e}}},741:t=>{t.exports=new class extends Array{addCard(t){this.push(t)}get getCards(){return this}get subtractFirstCard(){return this.shift()}shuffleCards(){this.sort(((t,e)=>.5-Math.random()))}}},614:(t,e,s)=>{const{PLAYER_TURN_DURATION:r}=s(719);t.exports=class{static turnDurationInSeconds=r;static timeLimit=this.turnDurationInSeconds;static countdownInterval=null;static startTimer(t){this.countdownInterval=setInterval((()=>{this.timeLimit>0?this.timeLimit--:(this.resetTimeLimit(),t&&t())}),1e3)}static resetTimeLimit(){this.timeLimit=this.turnDurationInSeconds}static stopTimer(){clearInterval(this.countdownInterval),this.resetTimeLimit()}static get getServerTime(){return(new Date).getTime()}static get getTurnRespondTime(){return this.turnDurationInSeconds}static getTimeData(){return{serverTime:this.getServerTime,turnRespondTime:this.getTurnRespondTime}}}},985:(t,e,s)=>{const r=s(437),a=s(616),n=s(653),i=s(285),o=s(341),l=s(739),c=s(469),u=s(521),d=s(905),y=s(614),h=s(733),P=s(549),p=s(120),{BUTTON_TYPES:g}=s(719),{MAX_PLAYERS:m,DEFAULT_PLAYER_GAME_POSITION:T,DEFAULT_PLAYER_BET_COUNT:R}=s(719);t.exports=class{static startGame(){u.initCards();const t=a.getPlayersAllData,e=o.initGamePositions(t),s=i.initBets(e,t),n=l.updatePlayersMoney(s,t),d=c.initPlayerIdGameTurn(e,t),y=r.initCards(t),{serverTime:p,turnRespondTime:g}=this.getGameTurnTimeData;return h.addPlayersBets(s),P.updateNextRound(),console.log(e),console.log(s),console.log(n),console.log(d),console.log(y),{playersGamePositions:e,playersBets:s,drawCardsForPlayers:y,playersMoney:n,playerIdGameTurn:d,serverTime:p,turnRespondTime:g}}static addPlayerToGame(t,e){const s=n.getEmptyPosition,r={...e};r.id=t,r.sit=s,r.check=!1,r.position=T,r.bet=R,a.addPlayer(t,r)}static startGameTurnTimer(t){y.stopTimer(),y.startTimer((()=>{t()}))}static changePlayerTurn(){const t=c.calculateNextPlayerIdTurn(),{serverTime:e,turnRespondTime:s}=this.getGameTurnTimeData;return{playerIdGameTurn:t,serverTime:e,turnRespondTime:s}}static get areAllPlayersDoneBetting(){const t=a.getPlayersObject,e=a.getBiggestBetFromPlayers,s=a.areAllPlayersCheck;return Object.values(t).every((t=>t.playerData.clientData.bet===e&&e>0||s||t.playerData.clientData.bet>0&&0===t.playerData.clientData.money))}static initNextRound(t){const e=u.getCardsFromDeck(t);d.addCards(e);const s=h.getBets,r=a.getSmallBLindPlayerData,{playerIdGameTurn:n,sitPosition:o}=r;c.setCurrentGameTurnPlayer(n,o),i.resetPlayersBets();const{serverTime:l,turnRespondTime:y}=this.getGameTurnTimeData;return P.updateNextRound(),a.resetPlayersSigns(),{newCardsOnTable:e,betsInPool:s,playerIdGameTurn:n,serverTime:l,turnRespondTime:y}}static playerTurnAction(t,e){const{action:s,data:r}=e,[n,i,o,l,c]=g,u={playerId:"",type:"",bet:null,money:null};if(s===i)a.setPlayerCheckStatus(t,!0),u.playerId=t,u.type=i;else if(s===o){const e=a.calculateBetDifferenceToHightest(t),{playerMoney:s,newBet:r}=this.handlePlayerBet(t,e);u.playerId=t,u.type=o,u.bet=r,u.money=s}else if(s===c){const{playerMoney:e,newBet:s}=this.handlePlayerBet(t,r);u.playerId=t,u.type=c,u.bet=s,u.money=e}return u}static handlePlayerBet(t,e){l.updatePlayerMoney(t,e);const s=a.getPlayerMoney(t);return i.updateBetOnServer(t,e),h.addBetToPot(e),{playerMoney:s,newBet:a.getPlayerBet(t)}}static isCurrentPlayerTurn(t){return c.isCurrentPlayerTurn(t)}static get isPreflopRoundFinish(){return this.areAllPlayersDoneBetting&&P.isPreflopRound}static get isFlopRoundFinish(){return this.areAllPlayersDoneBetting&&P.isFlopRound}static get isTurnRoundFinish(){return this.areAllPlayersDoneBetting&&P.isTurnRound}static get isRiverRoundFinish(){return this.areAllPlayersDoneBetting&&P.isRiverRound}static getGameResult(){const t=a.getPlayersCards,e=d.getTableCards,s=p.getPlayerWithBestCombination(t,e),r=h.getBets,{playerMoney:n}=this.handlePlayerBet(s,-r),i=n;return console.log(s),console.log("winner"),this.resetGame(),{playersCards:t,winnerPlayerId:s,betsInPool:r,winnerPlayerMoney:i}}static resetGame(){i.resetPlayersBets(),a.resetPlayersSigns()}static isGameWinner(){}static get getGameTurnTimeData(){return y.getTimeData()}static getPlayerFromGame(t){return a.getPlayerClientData(t)}static get getPlayersFromGame(){return a.getPlayersClientData}static deletePlayerFromGame(t){const e=a.getPlayerClientData(t);n.releasePosition(e.sit),a.deletePlayer(t)}static get areMaxPlayers(){return a.getPlayerCount==m}}},285:(t,e,s)=>{const r=s(616),{SMALL_BLIND_BET:a,BIG_BLIND_BET:n,GAME_POSITIONS:i}=s(719);t.exports=class{static initBets(t,e){const s=this.calculateBetsOnStart(t,e);return this.updateBetsOnServer(s),s}static updateBetsOnServer(t){for(const e in t){const s=t[e].bet;this.updateBetOnServer(e,s)}}static updateBetOnServer(t,e){const s=r.getPlayerBet(t)+e;r.updatePlayerBet(t,s)}static calculateBetsOnStart(t,e){return this.calculateMoneyAndBets(t,e)}static calculateMoneyAndBets(t,e){const s=a,r=n,o=i[1],l=i[2],c={};for(const a in e)c[a]={},t[a].position===l?c[a].bet=r:t[a].position===o?c[a].bet=s:c[a].bet=0;return c}static resetPlayersBets(){const t=r.getPlayersObject;for(const e in t)t[e].updateBet=0}}},437:(t,e,s)=>{const{MAX_PLAYER_CARDS:r}=s(719),a=s(616),n=s(521);t.exports=class{static initCards(t){const e=this.drawCardsAndAssignToPlayersID(t);return this.updatePlayersCardsOnServer(e),e}static updatePlayersCardsOnServer(t){for(const e in t){const s=t[e].cards;this.updatePlayerCardsOnServer(e,s)}}static updatePlayerCardsOnServer(t,e){a.updatePlayerCards(t,e)}static drawCardsAndAssignToPlayersID(t){const e={};for(const s in t){const t=[];for(let e=0;e<r;e++){const e=n.removeFirstCardFromDeck();t.push(e)}e[s]={cards:t}}return e}}},341:(t,e,s)=>{const{SIT_POSITIONS:r,GAME_POSITIONS:a,MAX_PLAYERS:n}=s(719),i=s(616);t.exports=class{static gamePositions=a;static initGamePositions(t){const e=this.getPlayersIDWithGamePositions(t);return this.updateGamePositionsOnServer(e),e}static updateGamePositionsOnServer(t){for(const e in t){const s=t[e].position;this.updateGamePositionOnServer(e,s)}}static updateGamePositionOnServer(t,e){i.updatePlayerGamePosition(t,e)}static getPlayersIDWithGamePositions(t){const e=this.drawPositions();return this.setPlayersPosition(e,t)}static drawPositions(){const t=this.drawDealer(),e=this.drawSmallBlind(t);return{dealer:t,smallBlind:e,bigBlind:this.drawBigBlind(e)}}static setPlayersPosition({dealer:t,smallBlind:e,bigBlind:s},r){const a={};for(const n in r)switch(a[n]={},r[n].clientData.sit){case t:a[n].position=this.gamePositions[0];break;case e:a[n].position=this.gamePositions[1];break;case s:a[n].position=this.gamePositions[2];break;default:a[n].position=this.gamePositions[3]}return a}static drawDealer(){const t=r;console.log(t);const e=Math.floor(Math.random()*t.length);return r[e]}static drawSmallBlind(t){return this.recalculatePlayersLimit(t)}static drawBigBlind(t){return this.recalculatePlayersLimit(t)}static recalculatePlayersLimit(t){let e=t+1;return this.isMoreThanMaxPlayers(e)&&(e=1),e}static isMoreThanMaxPlayers(t){return t>n}}},616:(t,e,s)=>{const r=s(736),a=s(790),{GAME_POSITIONS:n}=s(719);t.exports=class{static addPlayer(t,e){const s=new a(e);r.addPlayer(t,s)}static updatePlayerCards(t,e){this.getPlayer(t).updateCards=e}static updatePlayerMoney(t,e){this.getPlayer(t).updateMoney=e}static updatePlayerGamePosition(t,e){this.getPlayer(t).updateGamePosition=e}static updatePlayerBet(t,e){this.getPlayer(t).updateBet=e}static get getBiggestBetFromPlayers(){const t=this.getPlayersObject,e=[];for(const s in t){const r=t[s].getBet;e.push(r)}return Math.max(...e)}static get getSmallBLindPlayerData(){const t=this.getPlayersObject,e={};for(const s in t)if(t[s].getGamePosition===n[1]){const r=t[s].getSitPosition;e.playerIdGameTurn=s,e.sitPosition=r}return e}static get getPlayers(){return r.getPlayers}static getPlayer(t){return r.getPlayer(t)}static get getPlayersObject(){const t=this.getPlayers;return Object.fromEntries(t)}static get getPlayersClientData(){const t=this.getPlayersObject,e={};for(const s in t)e[s]=t[s].getClientData;return e}static get getPlayersAllData(){const t=this.getPlayersObject,e={};for(const s in t)e[s]=t[s].getData;return e}static getPlayerClientData(t){return this.getPlayer(t).getClientData}static get getPlayerCount(){return r.getPlayerCount}static deletePlayer(t){r.deletePlayer(t)}static setPlayerCheckStatus(t,e){this.getPlayer(t).setCheckStatus=e}static resetPlayersSigns(){const t=this.getPlayersObject;for(const e in t)this.setPlayerCheckStatus(e,!1)}static getPlayerBet(t){return this.getPlayer(t).getBet}static getPlayerMoney(t){return this.getPlayer(t).getMoney}static get getPlayersCards(){const t=this.getPlayersObject,e={};for(const s in t)e[s]=t[s].getCards;return e}static get areAllPlayersCheck(){const t=this.getPlayersObject;return Object.values(t).every((t=>!0===t.playerData.clientData.check))}static calculateBetDifferenceToHightest(t){return this.getBiggestBetFromPlayers-this.getPlayerBet(t)}}},739:(t,e,s)=>{const r=s(616);t.exports=class{static updatePlayersMoney(t,e){const s=this.calculatePlayersMoney(t,e);return this.updatePlayersMoneyOnServer(s),s}static updatePlayersMoneyOnServer(t){for(const e in t){const s=t[e].money;this.updatePlayerMoneyOnServer(e,s)}}static updatePlayerMoneyOnServer(t,e){r.updatePlayerMoney(t,e)}static calculatePlayersMoney(t,e){const s={};for(const r in e){s[r]={};const a=e[r],n=t[r].bet,i=this.calculatePlayerMoney(a,n);s[r].money=i}return s}static updatePlayerMoney(t,e){const s=r.getPlayer(t),a=this.calculatePlayerMoney(s,e);return this.updatePlayerMoneyOnServer(t,a),a}static calculatePlayerMoney(t,e){const s=t.getMoney||t.clientData.money,r=s-e;return r<0?s:r}}},790:t=>{t.exports=class{constructor(t){this.playerData={clientData:t,cards:[]}}get getClientData(){return this.playerData.clientData}get getData(){return this.playerData}get isCheck(){return this.playerData.clientData.check}get getBet(){return this.playerData.clientData.bet}get getId(){return this.playerData.clientData.id}get getGamePosition(){return this.playerData.clientData.position}get getSitPosition(){return this.playerData.clientData.sit}get getMoney(){return this.playerData.clientData.money}get getCards(){return this.playerData.cards}set updateGamePosition(t){this.playerData.clientData.position=t}set updateMoney(t){this.playerData.clientData.money=t}set updateBet(t){this.playerData.clientData.bet=t}set updateCards(t){this.playerData.cards=t}set setCheckStatus(t){this.playerData.clientData.check=t}}},653:(t,e,s)=>{const r=s(667);t.exports=class{static get getSmallestNumber(){const t=r.getSitPositions;return Math.min.apply(null,t)}static get getEmptyPosition(){return r.getEmptyPosition}static sortPositions(){r.sortPositions()}static releasePosition(t){r.addPosition(t),this.sortPositions()}}},736:(t,e,s)=>{const r=s(790);t.exports=new class{constructor(){this.players=new Map}createBotPlayers(){const t=[{nick:"Jan3",money:2e3,id:"FqwM02TqT",sit:5,position:"player",bet:0},{nick:"ZByszek",money:1e4,id:"SqwT22TqV",sit:4,position:"player",bet:0},{nick:"Adamoss",money:2e4,id:"GLw932TQF",sit:3,position:"player",bet:0},{nick:"Przmsidshadsdasd",money:1e5,id:"PGw962TU2",sit:2,position:"player",bet:0}];for(let e=0;e<t.length;e++){const s=t[e].id,a=new r(t[e]);this.addPlayer(s,a)}}addPlayer(t,e){this.players.set(t,e)}get getPlayerCount(){return this.players.size}get getPlayers(){return this.players}getPlayer(t){return this.players.get(t)}deletePlayer(t){this.players.delete(t)}}},469:(t,e,s)=>{const r=s(616),a=s(388),{GAME_POSITIONS:n,MAX_PLAYERS:i}=(s(667),s(719));t.exports=class{static initPlayerIdGameTurn(t,e){const s=this.getPlayerSitPositionGameTurn(t,e),r=this.getPlayerIdGameTurn(s);return a.setPlayerData(r,s),r}static calculateNextPlayerIdTurn(){const t=this.getNextPlayerSitPositionGameTurn(),e=this.getPlayerIdGameTurn(t);return a.setPlayerData(e,t),e}static getNextPlayerSitPositionGameTurn(){const t=a.getSitPosition;return this.calculateNextPlayerSitPositionGameTurn(t)}static calculatePlayerIdGameTurn(t,e){const s=this.getPlayerSitPositionGameTurn(t,e);return this.getPlayerIdGameTurn(s)}static getPlayerSitPositionGameTurn(t,e){const s=n[2];let r=null;for(const a in e)if(t[a].position===s){const t=e[a].clientData.sit;r=this.calculateNextPlayerSitPositionGameTurn(t)}return r}static getPlayerIdGameTurn(t){const e=r.getPlayersObject;let s=null;for(const r in e)e[r].playerData.clientData.sit===t&&(s=r);return s}static setCurrentGameTurnPlayer(t,e){a.setPlayerData(t,e)}static calculateNextPlayerSitPositionGameTurn(t){let e=t+1;return this.isMoreThanMaxPlayers(e)&&(e=1),e}static isMoreThanMaxPlayers(t){return t>i}static isCurrentPlayerTurn(t){return t===a.getId}}},120:t=>{t.exports=class{static getPlayerWithBestCombination(t,e){const s=this.calculatePlayersPokerHandCombinations(t,e),r=this.findPlayerWithBestCombination(s);return console.log(s),r}static calculatePlayersPokerHandCombinations(t,e){const s={};for(const r in t){const a=t[r];switch(!0){case this.hasRoyalFlush(a,e):pokerHandValue=9;break;case this.hasStraightFlush(a,e):pokerHandValue=8;break;case this.findFourOfAKind(a,e):pokerHandValue=7;break;case this.hasFullHouse(a,e):pokerHandValue=6;break;case this.hasFlush(a,e):pokerHandValue=5;break;case this.hasStraight(a,e):pokerHandValue=4;break;case this.hasThreeOfAKind(a,e):pokerHandValue=3;break;case this.hasTwoPairs(a,e):pokerHandValue=2;break;case this.hasOnePair(a,e):pokerHandValue=1;break;default:pokerHandValue=0}s[r]=pokerHandValue}return s}static findHighestCard(t){return t.sort(((t,e)=>e.value-t.value))[0]}static hasOnePair(t,e){const s=[...t,...e],r={};for(const t of s)r[t.value]?r[t.value]++:r[t.value]=1;for(const t in r)if(2===r[t])return!0;return!1}static hasTwoPairs(t,e){const s=[...t,...e],r={};s.forEach((t=>{const{value:e}=t;r[e]=(r[e]||0)+1}));let a=0;for(const t of Object.values(r))2===t&&a++;return 2===a}static hasThreeOfAKind(t,e){const s=[...t,...e],r={};return s.forEach((t=>{const e=t.value;r[e]=(r[e]||0)+1})),!!Object.keys(r).find((t=>3===r[t]))}static hasStraight(t,e){const s=[...t,...e].sort(((t,e)=>t.value-e.value));for(let t=0;t<s.length-4;t++){const e=s.slice(t,t+5);if(this.isStraight(e))return!0}return!1}static isStraight(t){for(let e=0;e<t.length-1;e++)if(parseInt(t[e].value)!==parseInt(t[e+1].value)-1)return!1;return!0}static hasFlush(t,e){const s=[...t,...e],r={};return s.forEach((t=>{const{suit:e}=t;r[e]||(r[e]=[]),r[e].push(t)})),!!Object.keys(r).find((t=>r[t].length>=5))}static hasFullHouse(t,e){const s=t.concat(e),r={};s.forEach((t=>{const e=t.value;r[e]=(r[e]||0)+1}));let a=!1,n=!1;for(const t in r)3===r[t]?a=!0:2===r[t]&&(n=!0);return a&&n}static findFourOfAKind(t,e){const s=[...t,...e],r={};s.forEach((t=>{r[t.value]?r[t.value]++:r[t.value]=1}));for(const t in r)if(4===r[t])return!0;return!1}static hasStraightFlush(t,e){const s=[...t,...e];s.sort(((t,e)=>t.value-e.value));for(let t=0;t<=s.length-5;t++){const e=s.slice(t,t+5),r=e.every((t=>t.suit===e[0].suit)),a=e.every(((t,s)=>!(s<4)||parseInt(t.value,10)+1===parseInt(e[s+1].value,10)));if(r&&a)return!0}return!1}static hasRoyalFlush(t,e){const s=[...t,...e],r=new Set,a=new Set;for(const t of s)r.add(t.suit);for(const t of r){const e=s.filter((e=>e.suit===t));if(e.length>=5){a.clear();for(const t of e)a.add(t.value);if(a.has("10")&&a.has("11")&&a.has("12")&&a.has("13")&&a.has("14"))return!0}}return!1}static findPlayerWithBestCombination(t){let e=null,s=-1/0;for(const r in t)if(t.hasOwnProperty(r)){const a=t[r];a>s&&(s=a,e=r)}return e}}},549:(t,e,s)=>{const r=s(813),{GAME_ROUND_NAMES:a}=s(719);t.exports=class{static updateNextRound(){const t=this.getActualRound,e=a.indexOf(t),s=this.calculateNextRoundIndex(e);this.setRoundName=s}static calculateNextRoundIndex(t){let e=t+1;return this.isLastRound(e)&&(e=0),e}static isLastRound(t){return t>a.length-1}static set setRoundName(t){const e=a[t];r.setName=e}static resetRoundName(){this.setRoundName=0}static get isPreflopRound(){return this.getActualRound===a[1]}static get isFlopRound(){return this.getActualRound===a[2]}static get isTurnRound(){return this.getActualRound===a[3]}static get isRiverRound(){return this.getActualRound===a[4]}static get getActualRound(){return r.getRoundName}}},813:(t,e,s)=>{const{GAME_ROUND_NAMES:r}=s(719);t.exports=new class{constructor(){this.roundName=r[0]}set setName(t){this.roundName=t}get getRoundName(){return this.roundName}}},388:t=>{t.exports=new class{constructor(){this.data={id:null,sitPosition:null}}get getPlayerData(){return this.data}get getId(){return this.data.id}get getSitPosition(){return this.data.sitPosition}setPlayerData(t,e){this.data.id=t,this.data.sitPosition=e}}},667:(t,e,s)=>{const{SIT_POSITIONS:r}=s(719);t.exports=new class{constructor(){this.sitPositions=[...r]}get getSitPositions(){return this.sitPositions}get getEmptyPosition(){return this.sitPositions.shift()}addPosition(t){this.sitPositions.push(t)}sortPositions(){this.sitPositions.sort((function(t,e){return t-e}))}}},733:(t,e,s)=>{const r=s(537);t.exports=class{static addBetToPot(t){const e=this.getBets+t;r.setBets=e}static addPlayersBets(t){for(const e in t){const s=t[e].bet;this.addBetToPot(s)}}static get getBets(){return r.getBets}}},537:t=>{t.exports=new class{constructor(){this.tableBets=0}set setBets(t){this.tableBets=t}get getBets(){return this.tableBets}}},905:(t,e,s)=>{const r=s(685);t.exports=class{static addCards(t){for(let e=0;e<t.length;e++){const s=t[e];r.addCard(s)}}static get getTableCards(){return r.getCards}}},685:t=>{t.exports=new class extends Array{addCard(t){this.push(t)}get getCards(){return this}}},237:(t,e,s)=>{const{SERVER_PORT:r}=s(239),a=s(611),n=s(174),i=s(252),o=i(),l=a.createServer(o),c=s(577),u=process.env.PORT||r,{Server:d}=s(301),y=new d({server:a.createServer(o)});o.use(c({origin:"*"})),o.use(n()),o.use(i.json()),o.use(i.static(`${__dirname}/../client`)),o.get("/",(function(t,e){e.sendFile(__dirname+"/index.html")})),t.exports={server:l,app:o,port:u,socketServer:y}},301:t=>{"use strict";t.exports=require("colyseus")},174:t=>{"use strict";t.exports=require("compression")},577:t=>{"use strict";t.exports=require("cors")},818:t=>{"use strict";t.exports=require("dotenv")},252:t=>{"use strict";t.exports=require("express")},829:t=>{"use strict";t.exports=require("jsonwebtoken")},37:t=>{"use strict";t.exports=require("mongoose")},982:t=>{"use strict";t.exports=require("crypto")},611:t=>{"use strict";t.exports=require("http")}},e={};function s(r){var a=e[r];if(void 0!==a)return a.exports;var n=e[r]={exports:{}};return t[r](n,n.exports,s),n.exports}(()=>{const{app:t,server:e,port:r,socketServer:a}=s(237),{authentication:n,registration:i}=s(203),o=s(740),l=s(198),{SOCKET_PORT:c}=s(239);e.listen(r,(async()=>{await o.connectDatabase(),t.post("/registration",i),t.post("/authentication",n),a.define("game",l),a.listen(c),console.log(`Listening on ${e.address().port}`)}))})()})();